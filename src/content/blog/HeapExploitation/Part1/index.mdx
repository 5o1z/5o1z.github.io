---
title: 'Heap Exploitation Part 1'
description: 'You will see the world is so big when you learn heap.'
image: '../cover_img_heapexp_imresizer.png'
date: '2025-04-24'
tags: ['Heap Exploitation']
authors: ['K.']
draft: false
---

## Prologue

When I first started learning about how memory works, I didn‚Äôt have a clear goal. I was just curious‚Äîwondering what really happens when a program asks for memory, uses it, and then gives it back.

That curiosity led me to the heap. At the beginning, everything felt a bit vague and confusing. But the more I read and explored, the more things started to make sense. I began to notice patterns, understand how memory is managed, and realize that the heap isn‚Äôt just a space for data‚Äîit‚Äôs a system. One that can be smart, complex, and sometimes easy to break if you know how.

That brings us to this series ‚Äî Heap Exploitation. This isn‚Äôt a perfect guide or a complete blog. It‚Äôs more like a learning journal: a place where I write down what I‚Äôve learned, what I‚Äôm still trying to understand, and what I wish I had known earlier. So, I'm sharing it in the hope that it might help someone else who‚Äôs also starting out, or just curious like I was.

I‚Äôll keep updating it over time as I learn more and get better at explaining things. Think of it as a work-in-progress ‚Äî something that grows along with my journey.

If you‚Äôre also someone who learns by exploring and asking `how does this really work?`, then welcome. Let‚Äôs go through the heap together.

## Overview

Memory is part of how everything works in every program. Each time a program is run, it must allocate memory to store data, variables, and other information. This is generally subdivided into different areas, and two of its most fundamental ones are the stack and the heap.

Maybe you have used the stack‚Äîit is a box into which you stack up objects and unstack them in order. It is fast and convenient but restrictive. The heap is a different kind of area in memory. It is more flexible. The program may request memory from the heap at runtime and keep it as long as it needs.

It is this flexibility that renders the heap such a handy resource, especially for programs that handle much data or have little idea how much space they will need when they start. More control, though, means more risk. Memory on the heap is more difficult to handle. When not adequately controlled, unmanaged memory creates problems like crashes, slowdowns, or even serious security risks.

According to many sources, heap-related bugs play a big role in real-world exploitation. Therefore, learning how heaps work is not only cool‚Äîit's worth knowing if you want to create more secure, improved apps or even want to learn how various forms of exploits take place.

Throughout this series, we will talk about how the heap is built, how memory is allocated and released via functions such as malloc and free, and how an attacker would exploit vulnerabilities in the system. We will take it step by step, starting with basics and progressing on to real techniques in heap exploitation (possibly in CTF context). There is no rush‚Äîlet us do this step by step.

## Lab Environment

To make it easier to test sample code or try things out for yourself, I‚Äôve created a Docker environment. You can download it here:
<a href="/public/HeapExploitation/Part1/lab-env.zip" download="lab-env.zip" style={{ textDecoration: 'none', color: 'white' }}>
  <button style={{ padding: '10px 16px', fontSize: '1rem', cursor: 'pointer' }}>
    üì¶ Download Docker Environment
  </button>
</a>

The environment is based on `Ubuntu 18.04` with `GLIBC 2.27`. I chose this version because it‚Äôs a good for learning and getting familiar with how the heap works. It‚Äôs not the latest version, but it‚Äôs stable and widely used. I also included `pwndbg` for debugging, which is a great tool for analyzing memory and understanding how things work under the hood.

After downloading the zip file, just follow these steps:

1. Run the script: `setup_pwndbg.sh`

2. Then run: `run.sh`

Feel free to customize the environment to fit your own setup or experiments.

## Heap Structure

When I first learned about the heap, I imagined it as just a large block of memory where data gets stored when needed. But the more I explored, the more I realized that it‚Äôs not random at all‚Äîit‚Äôs actually a well-organized system with its own layout and rules.

Each time a program calls `malloc` or `free`, it‚Äôs interacting with this structure. The allocator needs to know which parts of memory are free, which are used, and how to manage everything quickly and safely.

Let‚Äôs explore how the heap is organized. We‚Äôll look at how memory is divided into chunks, how those chunks are tracked, and how the heap grows when needed. This is the foundation that will help us understand not just how programs work with memory, but also how attackers can take advantage of it.

Once you understand the structure, a lot of things that seem like ‚Äúmagic‚Äù will start to make sense.

### Chunk

#### Overview

A chunk is the name given to a block of memory that is managed by the heap. When you call the malloc function, the memory you get back actually comes from a chunk.

Each chunk is a small part of the heap and follows a specific structure. This structure helps the allocator know how big the chunk is, whether it's in use or free, and where the next chunk is.

In memory, a chunk isn‚Äôt just raw space‚Äîit includes metadata that the allocator uses to manage things properly. This metadata is stored along with the chunk itself, just before the area that your program uses.

Here‚Äôs what a basic chunk structure looks like:

```c title="malloc.c:1060-1071" caption="malloc chunk structure" collapse={9-11}
struct malloc_chunk {

  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
```

To keep things simple and avoid confusion, I‚Äôve left out the last two fields in the `malloc_chunk` structure. But for now, you only need to focus on the four most important parts:

- `prev_size` ‚Äì the size of the previous chunk (used when it‚Äôs free)

- `chunk_size` ‚Äì the size of the current chunk, including some flags

- `fd` ‚Äì forward pointer (used when the chunk is free and part of a bin)

- `bk` ‚Äì backward pointer (also used in bins for linking chunks)

These four fields play a key role in how the heap keeps track of memory and manages free chunks. Don‚Äôt worry if they sound a bit abstract right now‚Äîwe‚Äôll go over each one in more detail shortly.
you can see how they actually work in practice.

Also, you can take a look at the image below to get a better idea of what a chunk looks like in memory and how these fields are laid out.

![chunk](./assets/chunk.png)

From the image above, we can see that a chunk consists of two main parts: `metadata` and user `data`.

The metadata (aka chunk header) part contains information used by the memory allocator, such as `prev_size` and `size`. These fields are not part of the memory you directly use in your program‚Äîthey're used internally to keep track of the chunk's size, status, and position in the heap.

In addition, we can also see that the heap grows upward in memory. This means that each new chunk is placed after the previous one, following a continuous order. Older chunks remain at lower memory addresses, while newer chunks are added at higher addresses.

But wait!! Earlier we saw that a `malloc_chunk` includes both `fd` and `bk` pointers. So why aren‚Äôt they shown in the image above? The answer is those fields only become relevant when a chunk is freed.

When a chunk is in use (allocated), the space where `fd` and `bk` would normally be is part of the user data. But once the chunk is freed, that space is reused by the allocator to store `fd` (forward pointer) and `bk` (backward pointer), which are used to link free chunks together in bins.

So if you‚Äôre looking at an allocated chunk in memory, you won‚Äôt see `fd` and `bk` but they‚Äôll show up once the chunk is no longer in use.

We can look at the image below to easily visualize what a free chunk will look like:

![freed chunk](./assets/freed_chunk.png)

We will see that there will be two more things appearing, `fd` (forward pointer) and `bk` (backward pointer). As the name suggests, these two pointers will point to the previous and next chunks in the free list (I will explain this more clearly when we get to the bins section).

#### Size bits

```c title="malloc.c:1272-1279" caption="Size bits
/*
   Bits to mask off when extracting size

   Note: IS_MMAPPED is intentionally not masked off from size field in
   macros for which mmapped chunks should never be seen. This should
   cause helpful core dumps to occur if it is tried by accident by
   people extending or adapting this malloc.
 */
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
```

We can see in the chunk layout image above that there are letters like A, M, and P shown next to the size field. These letters represent internal flags that are stored inside the chunk‚Äôs size value. They‚Äôre not part of the actual size but are packed into the same field for efficiency. This is where `SIZE_BITS` comes in.
SIZE_BITS is a bitmask used to mark which bits in the chunk‚Äôs size field are reserved for internal flags. These flags help the allocator keep track of extra information about the chunk.

When you want to get the real size of a chunk (excluding the flags), you need to perform a bitwise AND (&) between the chunk‚Äôs size and the inverse of SIZE_BITS. This operation clears the flag bits and leaves you with just the actual size.

The flags stored inside the size field include:

- `PREV_INUSE` (`P` - `0x1`): This bit tells whether the previous chunk is currently in use.

- `IS_MMAPPED` (`M`- `0x2`): Indicates whether this chunk was allocated using mmap instead of the heap.

- `NON_MAIN_ARENA` (`A` - `0x4`): Marks whether the chunk is part of a non-main arena, which can happen in multi-threaded programs.

These flags are packed into the same field as the chunk size, so we have to remove them first before we can get the real size value.

#### Demo

And to understand better, we will go into the following demo. We will have the source code as follows, copy it and compile it in the Docker environment I left above.

```c title="demo.c"
// gcc demo.c -no-pie -o demo -g
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char *ptr1 = malloc(0x20);  // <-------- Chunk size will be 0x30 (0x10 metadata)
    char *ptr2 = malloc(0x200);
    char *ptr3 = malloc(0x2000);
    char *ptr4 = malloc(0x20000);

    strcpy(ptr1, "Hello World");

    return 0;
}
```

Debug it in `gdb` and set a breakpoint at the `malloc` function. You can do this by running the following command in the terminal:

```bash
pwndbg> bp *main+13
pwndbg> run
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
             Start                End Perm     Size Offset File
          0x400000           0x401000 r-xp     1000      0 /root/demo
          0x600000           0x601000 r--p     1000      0 /root/demo
          0x601000           0x602000 rw-p     1000   1000 /root/demo
    0x7ffff79e2000     0x7ffff7bc9000 r-xp   1e7000      0 /lib/x86_64-linux-gnu/libc-2.27.so
    0x7ffff7bc9000     0x7ffff7dc9000 ---p   200000 1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
    0x7ffff7dc9000     0x7ffff7dcd000 r--p     4000 1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
    0x7ffff7dcd000     0x7ffff7dcf000 rw-p     2000 1eb000 /lib/x86_64-linux-gnu/libc-2.27.so
    0x7ffff7dcf000     0x7ffff7dd3000 rw-p     4000      0 [anon_7ffff7dcf]
    0x7ffff7dd3000     0x7ffff7dfc000 r-xp    29000      0 /lib/x86_64-linux-gnu/ld-2.27.so
    0x7ffff7fee000     0x7ffff7ff0000 rw-p     2000      0 [anon_7ffff7fee]
    0x7ffff7ff6000     0x7ffff7ffa000 r--p     4000      0 [vvar]
    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000      0 [vdso]
    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  29000 /lib/x86_64-linux-gnu/ld-2.27.so
    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2a000 /lib/x86_64-linux-gnu/ld-2.27.so
    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]
    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]
0xffffffffff600000 0xffffffffff601000 r-xp     1000      0 [vsyscall]
```

We see that before `malloc` is executed for the first time, there is no such thing as a `heap`. Because as mentioned before, the heap only really appears when we execute `malloc` for the first time. Don't worry about this, because I will explain how malloc works in the next section `How malloc and free work`. For now, just know that, before `malloc` is executed for the first time, there is no such thing as a heap.

`malloc` for the first time:

```bash
pwndbg> vis
0x602250        0x0000000000000000      0x0000000000000031      ........1.......
0x602260        0x0000000000000000      0x0000000000000000      ................
0x602270        0x0000000000000000      0x0000000000000000      ................
0x602280        0x0000000000000000      0x0000000000020d81      ................         <-- Top chunk
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
             Start                End Perm     Size Offset File
          0x400000           0x401000 r-xp     1000      0 /root/demo
          0x600000           0x601000 r--p     1000      0 /root/demo
          0x601000           0x602000 rw-p     1000   1000 /root/demo
          0x602000           0x623000 rw-p    21000      0 [heap]
    0x7ffff79e2000     0x7ffff7bc9000 r-xp   1e7000      0 /lib/x86_64-linux-gnu/libc-2.27.so
    0x7ffff7bc9000     0x7ffff7dc9000 ---p   200000 1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
    0x7ffff7dc9000     0x7ffff7dcd000 r--p     4000 1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
    0x7ffff7dcd000     0x7ffff7dcf000 rw-p     2000 1eb000 /lib/x86_64-linux-gnu/libc-2.27.so
    0x7ffff7dcf000     0x7ffff7dd3000 rw-p     4000      0 [anon_7ffff7dcf]
    0x7ffff7dd3000     0x7ffff7dfc000 r-xp    29000      0 /lib/x86_64-linux-gnu/ld-2.27.so
    0x7ffff7fee000     0x7ffff7ff0000 rw-p     2000      0 [anon_7ffff7fee]
    0x7ffff7ff6000     0x7ffff7ffa000 r--p     4000      0 [vvar]
    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000      0 [vdso]
    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  29000 /lib/x86_64-linux-gnu/ld-2.27.so
    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2a000 /lib/x86_64-linux-gnu/ld-2.27.so
    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]
    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]
0xffffffffff600000 0xffffffffff601000 r-xp     1000      0 [vsyscall]
```
After malloc the heap appears and so on for subsequent mallocs new chunks will be allocated but if you pay attention to the `malloc(0x20000)` you will not see it when using the `vis` command. That is because the requested size is too large and `malloc` cannot extract a part from `topchunk` (I will explain about topchunk later), so it used vmmap to allocate that memory, and that memory will definitely have bit `2` turned on

### Top chunk

**Top chunk** (known as the **topmost available chunk**) is essentially a large heap chunk that holds currently unallocated data. After a new arena is initialized a top chunk always exists and there is only ever one per arena. For example, when you call `malloc(0x10)` (which means you want 16 bytes of memory), and it's the first time using `malloc`, the heap is not ready yet. So, `malloc` asks the operating system (kernel) for a much bigger block of memory, maybe around **20,000 bytes**. This is more efficient than asking for memory every time. From that large block, `malloc` gives you 16 bytes plus some extra bytes for its own tracking (called metadata). The rest of the unused memory is saved in something called the **top chunk**, which is a special area that holds free memory. This top chunk is not in the free list (also called the bin list), but it's ready to be used for future `malloc` calls.

Each time you request memory, a small part of the top chunk is used, so the top chunk becomes smaller and smaller over time. When the top chunk is too small to give you the memory you asked for (and your request is smaller than the `mmap` threshold - **`mmap`** limit), `malloc` tries to grow the heap using a function called `sysmalloc()`. If this works, the top chunk is made bigger. But if it fails, a **new heap is created**, and its **top chunk becomes the new top chunk** of the **same arena**. The memory left in the old top chunk is then freed and can be reused. To protect against bugs when chunks are merged, `malloc` adds two fake chunks (called **fenceposts**) of size 0x10 at the end of the heap. These help stop the program from reading outside the heap by mistake. The top chunk‚Äôs size field shows how much space is left, and its `prev_inuse` bit is always set. This chunk is always big enough to give out the smallest allowed chunk, and it always ends exactly at the end of a memory page.

## How malloc and free work

### ptmalloc2

### malloc

### free

## Epilogue
